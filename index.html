<!DOCTYPE html>
<html>
  <head>
    <title>dxf-to-ggb-converter</title>
  </head>
  <body>
    <script
      src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"
      type="text/javascript"
    ></script>
    <script
      src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"
      type="text/javascript"
    ></script>
    <script
      src="https://unpkg.com/dxf-parser@1.1.2/dist/dxf-parser.js"
      type="text/javascript"
    ></script>

    <h3>1. Select an ALKIS-DXF file</h3>
    <input id="inputfile" type="file" name="inputfile" />
    <h3>2. Select and costumize the layerSymbols you want to export</h3>
    <table id="layerList"></table>
    <h3>3. Export the data as a GGB file for Geogebra</h3>
    <button id="submit" onclick="exportGbbFile()">Export to GGB</button>
    <br />
    <br />
    <hr />
    <h3>Debug Output:</h3>
    <pre id="output"></pre>

    <script>
      "use strict";

      let fileName = "test";

      // final data - important for the export
      let usedLayerEntryTypes = new Map();
      let points = {};
      let ggbSegments = {};
      let texts = {};

      // add listener for file input
      let fileInputElement = document.getElementById("inputfile");
      fileInputElement.addEventListener("change", function () {
        let inputReader = new FileReader();
        let file = this.files[0];
        fileName = file.name;
        inputReader.onload = function () {
          processFile(inputReader);
        };
        inputReader.readAsText(file);
      });

      // process file
      function processFile(inputReader) {
        // parse dxf file
        let dxfContent = inputReader.result;
        const parser = new DxfParser();
        try {
          let dxf = parser.parseSync(dxfContent);
          extractXmlFromDxf(dxf);
        } catch (err) {
          document.getElementById("output").textContent =
            "ERROR: Something might be wrong with the provided dxf file!\n\n" +
            err.name +
            ", " +
            err.message +
            ": \n" +
            err.stack;
        }
      }

      function extractXmlFromDxf(dxf) {
        // reset if file is changed
        usedLayerEntryTypes = new Map();
        points = {};
        ggbSegments = {};
        texts = {};

        // COMMENT mark exists?  1xxx = yes, 9xxx = no
        let pointTypesMap = {
          1000: "allgemeineMarke",
          1200: "Rohr",
          1120: "unbehauenerFeldstein",
          1110: "Grenzstein",
          1650: "Klebemarke",
          1500: "Pfahl",
          1655: "Schlagmarke",
          1400: "Meisselzeichen",
          1300: "Nagel",
          9500: "ohneMarke",
          9998: "NachQuellangabenNichtZuSpezifizieren",
          9600: "AbmarkungZeitweiligAusgesetzt",
        };

        // remember layers for the layer colors later on
        const layers = dxf.tables.layer.layers;

        // temporary variables for conversion
        let dxfVectorToGgbPointMap = {};
        let dxfPolyLines = {};

        // find additional info in dxf.blocks
        let additionalInfos = {};
        const blocks = dxf.blocks;
        for (const key in blocks) {
          let block = blocks[key];
          additionalInfos[block.name] = {};
          additionalInfos[block.name].layer = block.layer;
          additionalInfos[block.name].comment = block.name2;
        }
        // find main info about e.g. coordinates in dxf.entities
        let entities = dxf.entities;
        for (const entity of entities) {
          let layerEntryType =
            entity.type +
            " " +
            entity.layer +
            (entity.name ? " " + entity.name : "");
          let subtypeName =
            pointTypesMap[entity?.name?.replace("ABM_", "")] ?? entity.name;
          if (!usedLayerEntryTypes.has(layerEntryType)) {
            let value = {};
            value.type = entity.type;
            value.subtypeId = entity.name;
            value.subtypeName = subtypeName;
            value.layer = entity.layer;
            value.color =
              "#" +
              layers[entity.layer].color
                .toString(16)
                .toLowerCase()
                .padStart(6, 0);
            usedLayerEntryTypes.set(layerEntryType, value);
          }

          let key;
          switch (entity.type) {
            // TODO delete unnecessary attributes
            case "INSERT":
              key = "P" + parseHandle(entity.handle);
              points[key] = {};
              points[key].entryType = layerEntryType;
              points[key].layer = entity.layer;
              points[key].x = entity.position.x;
              points[key].y = entity.position.y;
              points[key].subtypeId = entity.name;
              points[key].subtypeName = subtypeName;
              const info = additionalInfos[entity.name];
              if (info.layer == entity.layer) {
                points[key].comment = info.comment;
              }
              let vectorKey = entity.position.x + "," + entity.position.y;
              dxfVectorToGgbPointMap[vectorKey] = key;
              break;
            case "LINE":
            case "LWPOLYLINE":
              key = "L" + parseHandle(entity.handle);
              dxfPolyLines[key] = {};
              dxfPolyLines[key].entryType = layerEntryType;
              dxfPolyLines[key].layer = entity.layer;
              dxfPolyLines[key].vertices = entity.vertices;
              break;
            case "TEXT":
              key = "T" + parseHandle(entity.handle);
              texts[key] = {};
              texts[key].entryType = layerEntryType;
              texts[key].layer = entity.layer;
              texts[key].x = entity.startPoint.x;
              texts[key].y = entity.startPoint.y;
              texts[key].text = entity.text;
              break;
            default:
              break;
          }
        }
        // find and add node handles for lines and polylines
        for (const key in dxfPolyLines) {
          let line = dxfPolyLines[key];
          // set first start point
          let startPoint = line.vertices[0];
          let startVectorKey = startPoint.x + "," + startPoint.y;
          // add segments from (poly)line
          for (let i = 1; i < line.vertices.length; i++) {
            // find end point
            let endPoint = line.vertices[i];
            let endVectorKey = endPoint.x + "," + endPoint.y;
            // segment handle
            let ggbSegmentKey = key + "L" + i.toString(10);
            // create points if they don't exist
            if (!dxfVectorToGgbPointMap[startVectorKey]) {
              createPoint(
                usedLayerEntryTypes,
                dxfVectorToGgbPointMap,
                startPoint,
                ggbSegmentKey + "S"
              );
            }
            if (!dxfVectorToGgbPointMap[endVectorKey]) {
              createPoint(
                usedLayerEntryTypes,
                dxfVectorToGgbPointMap,
                endPoint,
                ggbSegmentKey + "G"
              );
            }
            // add new segment to ggbSegments
            ggbSegments[ggbSegmentKey] = {};
            ggbSegments[ggbSegmentKey].entryType = line.entryType;
            ggbSegments[ggbSegmentKey].layer = line.layer;
            ggbSegments[ggbSegmentKey].startPoint =
              dxfVectorToGgbPointMap[startVectorKey];
            ggbSegments[ggbSegmentKey].endPoint =
              dxfVectorToGgbPointMap[endVectorKey];
            // set end point as start point for next line segment
            startPoint = endPoint;
          }
        }

        // show used layers and
        // TODO add an option to select wanted ones
        // 1. add an html element for each and provide an option to remove each one
        // 2. provide an option to asign point/line/text types
        //    (and duplicate policies -> nichtfestgestellteGrenze line stays; flurstueck line is removed)
        //    What about line-point dependencies?
        // 3. collect the remaining ones afterwards

        // sort usedLayerEntryTypes by key
        usedLayerEntryTypes = new Map(
          [...usedLayerEntryTypes.entries()].sort()
        );

        // show usedLayerEntryTypes
        let layerTable = document.getElementById("layerList");
        layerTable.textContent = "";
        for (const [key, entryType] of usedLayerEntryTypes) {
          // create layer item
          let tableRow = layerTable.insertRow(-1);
          tableRow.id = key;
          // selected - are the items of this layer included in the export?
          let cell0 = tableRow.insertCell(0);
          let selectedSelectorId = key + "_selected";
          let selectCheckbox = document.createElement("input");
          selectCheckbox.className = "selected";
          selectCheckbox.type = "checkbox";
          selectCheckbox.checked = true;
          selectCheckbox.id = selectedSelectorId;
          cell0.appendChild(selectCheckbox);
          // selected - label
          let labelId = key + "_label";
          let label = document.createElement("label");
          label.textContent =
            entryType.type +
            " " +
            entryType.layer +
            (entryType.subtypeName ? " " + entryType.subtypeName : "");
          label.htmlFor = selectedSelectorId;
          label.id = labelId;
          cell0.appendChild(label);
          // point or line style for the items of this layer
          let cell1 = tableRow.insertCell(1);
          let styleSelectorId = key + "_style";
          let styleSelector =
            entryType.type == "INSERT" || entryType.type == "TEXT"
              ? createPointStyleSelector(styleSelectorId)
              : createLineStyleSelector(styleSelectorId);
          cell1.appendChild(styleSelector);
          // color for the items of this layer
          let cell2 = tableRow.insertCell(2);
          let colorSelectorId = key + "_color";
          let colorSelector = document.createElement("input");
          colorSelector.className = "color";
          colorSelector.type = "color";
          colorSelector.value = entryType.color;
          colorSelector.id = colorSelectorId;
          cell2.appendChild(colorSelector);
          // size for the items of this layer
          let cell3 = tableRow.insertCell(3);
          let sizeSelectorId = key + "_size";
          let sizeSelector = document.createElement("input");
          sizeSelector.className = "size";
          sizeSelector.type = "number";
          sizeSelector.value = entryType.type == "INSERT" ? 3 : 2;
          sizeSelector.size = 4;
          sizeSelector.min = 1;
          sizeSelector.max = entryType.type == "INSERT" ? 9 : 13;
          cell3.appendChild(sizeSelector);
        }

        // TODO add an option to move all points by two values towards the origin (0, 0)
      }

      function parseHandle(handle) {
        return parseInt(handle, 16).toString(10);
      }

      function createPoint(
        usedLayerEntryTypes,
        vectorToPointMap,
        newPoint,
        segmentPointHandle
      ) {
        let type = "INSERT";
        let layer = "linienpunkt_sonstiger";
        let subtypeId = "UNBEKANNT";
        let subtypeName = "Unbekannt";

        let layerEntryType = type + " " + layer + " " + subtypeId;
        if (!usedLayerEntryTypes.has(layerEntryType)) {
          let value = {};
          value.type = type;
          value.subtypeId = subtypeId;
          value.subtypeName = subtypeName;
          value.layer = layer;
          value.color = "#dbdbdb";
          usedLayerEntryTypes.set(layerEntryType, value);
        }

        const key = "P" + segmentPointHandle;
        points[key] = {};
        points[key].entryType = layerEntryType;
        points[key].layer = layer;
        points[key].x = newPoint.x;
        points[key].y = newPoint.y;
        points[key].subtypeId = subtypeId;
        points[key].subtypeName = subtypeName;
        let vectorKey = newPoint.x + "," + newPoint.y;
        vectorToPointMap[vectorKey] = key;
      }

      function createPointStyleSelector(styleSelectorId) {
        let dotStyles = ["⏺", "x", "⭘", "+", "◆", "◇", "⮝", "⮟", "⮞", "⮜"];
        let styleSelector = document.createElement("select");
        styleSelector.className = "style";
        styleSelector.id = styleSelectorId;
        for (const i in dotStyles) {
          const style = dotStyles[i];
          var option = document.createElement("option");
          option.value = i;
          option.text = style;
          styleSelector.appendChild(option);
        }
        return styleSelector;
      }

      function createLineStyleSelector(styleSelectorId) {
        let dotStyles = { 0: "-----", 15: "- - -" };
        let styleSelector = document.createElement("select");
        styleSelector.className = "style";
        styleSelector.id = styleSelectorId;
        for (const i in dotStyles) {
          const style = dotStyles[i];
          var option = document.createElement("option");
          option.value = i;
          option.text = style;
          styleSelector.appendChild(option);
        }
        return styleSelector;
      }

      function exportGbbFile() {
        // TODO remove duplicate lines

        // read layer costumisations from ui
        let layerStyles = {};
        let layerList = document.getElementById("layerList");
        let layerListElements = layerList.children[0].children;
        for (const element of layerListElements) {
          let value = {};
          value.selected =
            element.getElementsByClassName("selected")[0].checked;
          value.style = element.getElementsByClassName("style")[0].value;
          value.color = element.getElementsByClassName("color")[0].value;
          value.size = element.getElementsByClassName("size")[0].value;
          layerStyles[element.id] = value;
        }

        // prepare xml data for final file
        let ggbContent;

        // TODO create the xml ggbContent from the maps and objects above

        // saveToGGB(ggbContent);

        // for Debug
        let dxfToJson =
          "\n\n-------------------------------------------------------\n\n" +
          JSON.stringify(layerStyles, null, 2) +
          "\n\n-------------------------------------------------------\n\n" +
          JSON.stringify(points, null, 2) +
          "\n\n-------------------------------------------------------\n\n" +
          JSON.stringify(ggbSegments, null, 2) +
          "\n\n-------------------------------------------------------\n\n" +
          JSON.stringify(texts, null, 2);
        document.getElementById("output").textContent = dxfToJson;
      }

      // output file to the download folder
      function saveToGGB(ggbContent) {
        // start zip creation
        let zip = new JSZip();
        // create an empty geogebra.xml file
        // and add the elements and commands from the ggbContent
        let xmlHeader = '<?xml version="1.0" encoding="utf-8"?>\n';
        let ggbHeader =
          '<geogebra format="5.0" >\n' +
          '<construction title="" author="" date="">\n';
        let ggbFooter = "</construction>\n" + "</geogebra>\n";
        zip.file(
          "geogebra.xml",
          xmlHeader + ggbHeader + ggbContent + ggbFooter
        );
        // save as ziped ggb file
        zip.generateAsync({ type: "blob" }).then(function (content) {
          saveAs(content, fileName + ".ggb");
        });
      }
    </script>
  </body>
</html>
